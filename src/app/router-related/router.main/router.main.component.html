<p>
	RouteParams QueryParams Fragment ConvertNum ChildRoute QueryHandling WildCard NoFound(err)Page RouteGuard-CanDeactivate-CanActive-CanLoad
	Redirect ResolveDynamicData RouteGuard(service and child) LocalStrategy
</p>
<div class="ui stackable four column grid">
	<div class="column">
		<p>
			when component is main compo of a module, donot need router-outlet, but if it is a compo inject into another compo, then
			you should use router-outlet
			<br /> the place to use router-outlet is same position to use component (app-nested-content) --> if you want to go there (the
			next compo), add &lt;a [routerLink]="['/next-compo']"&gt; on top of it.
		</p>
		<!-- <app-nested-content></app-nested-content> -->
		<a [routerLink]="['/next-compo']">
			Go Next Component
		</a>
		<router-outlet></router-outlet>
	</div>
	<div class="column">
		Usually, if we give CanActivate guard to parent route, all child routes would be blocked. Thus, it is better us CanActivateChild,
		block children, not parent.
		<br />
		<em class="fz2em">
			Mention one thing --> Due to service donot have meta data (html, css, js), so if you want to inject it into Module or Component,
			you should give @Injectable(). But, if you want to inject a service into another service, donot need Injectable.
		</em>
	</div>
	<div class="column">
		<em class="fz2em">
			To support old browser, we have to add old hash route (route-local-Strategy) in root route module.
		</em>
		<img src="../../../assets/imgs/old-browser-hash-route.png" class="hash-route" alt="route-local-Strategy" />
		<cite class="fz2em">
			<br /> you can see # in the url. In this way, webserver will only care the thing before /#, so it will let webserver read correct
			route, because webserver will use localhost://4200/ as root and replace it with server/, then pluse route --> server/route.
		</cite>
	</div>
	<div class="column">
	</div>
</div>
<div class="ui divider hidden"></div>
<div class="ui divider hidden"></div>
